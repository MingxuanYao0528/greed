#!/usr/bin/env python3
import argparse
import logging
import random

from web3 import Web3

from SEtaac import Project
from SEtaac import options
from SEtaac.exploration_techniques import DFS, DirectedSearch, HeartBeat, ExplorationTechnique
from SEtaac.utils import gen_exec_id
from SEtaac.utils.solver.shortcuts import *

LOGGING_FORMAT = "%(levelname)s | %(name)s | %(message)s"
logging.basicConfig(level=logging.INFO, format=LOGGING_FORMAT)
log = logging.getLogger("exploit_generator")

# get w3 instance
# w3 = Web3(Web3.HTTPProvider('http://localhost:8545'))


# todo: save exploit contexts (reads and writes w/ paths + iterator, if exhausted we can go back to iterators)
# todo: inspect unsat reads after every transaction, not just at the end

# def execute_trace(entry_state, trace):
#     p = entry_state.project
#
#     # todo: rewrite this to execute a series of ops
#     simgr = p.factory.simgr(entry_state=entry_state)
#
#     for target_stmt in trace:
#         simgr.move(from_stash='found', to_stash='active')
#         target_block = p.factory.block(stmt.block_id)
#         simgr.run(find=lambda s: s.curr_stmt == target_stmt,
#                   prune=lambda s: not is_reachable(s, target_block),
#                   find_all=True)
#
#     return simgr


class MonitorSLOAD(ExplorationTechnique):
    def setup(self, simgr):
        for state in simgr.states:
            if 'observed_offsets' not in state.globals:
                state.globals['observed_offsets'] = set()

    def check_state(self, simgr, state):
        if state.curr_stmt.__internal_name__ == "SLOAD":
            state.curr_stmt.set_arg_val(state)
            storage_offset = state.curr_stmt.arg1_val
            state.globals['observed_offsets'].add(storage_offset)

        return state


class Exploit:
    def __init__(self, project):
        self.project = project

        # list of (calldata, trace, unsat_reads) for every transaction
        self.transactions = list()

        self.final_state = None
        self.unsat_reads = set()

    def _is_sat(self, storage=None):
        storage = storage or dict()

        sat = True
        xid = 1
        options.LAZY_SOLVES = False
        entry_state = self.project.factory.entry_state(xid=xid, max_calldatasize=256)

        for off, value in storage.items():
            entry_state.storage[off] = value

        for calldata, _, _ in self.transactions:
            init_ctx = {"CALLDATA": calldata, "CALLDATASIZE": len(calldata)}
            entry_state = entry_state.copy()
            entry_state.reset(xid=xid)
            entry_state.set_init_ctx(init_ctx=init_ctx)

            caller = ctx_or_symbolic('CALLER', entry_state.ctx, entry_state.xid)
            entry_state.add_constraint(NotEqual(BV_Shl(caller, BVV(256-160, 256)), BVV(0, 256)))

            entry_state.pc = self.project.factory.block('0x0').first_ins.id
            simgr = self.project.factory.simgr(entry_state=entry_state)

            dfs = DFS()
            simgr.use_technique(dfs)

            monitor_sload = MonitorSLOAD()
            simgr.use_technique(monitor_sload)

            simgr.run(find=lambda s: (s.halt and
                                      not s.error and
                                      s.trace[-1].__internal_name__ != 'REVERT'))
            if not simgr.found:
                self.final_state = None
                self.unsat_reads = set.union(*[Exploit._get_all_reads(s) for s in simgr.states])
                sat = False
                break

            self.final_state = simgr.one_found
            entry_state = simgr.one_found
            xid += 1

        return sat

    def is_sat_local(self):
        return self._is_sat()

    def is_sat_remote(self):
        # pull on-chain storage
        all_reads = set.union(*[t[2] for t in self.transactions])
        storage = {off: BVV(0, 256) for off in all_reads}

        return self._is_sat(storage=storage)

    @staticmethod
    def _get_calldata(state):
        calldata_size = state.MAX_CALLDATA_SIZE
        calldata = state.solver.eval_memory(state.calldata, BVV(calldata_size, 256)).to_bytes(calldata_size, 'big').hex()
        log.info(f'CALLDATA: {calldata}')
        return calldata

    @staticmethod
    def _get_all_reads(state):
        # for off in state.globals['observed_offsets']:
        #     assert (is_concrete(off))
        all_reads = [off for off in state.globals['observed_offsets']]
        return set(all_reads)

    def refine(self):
        # todo: need to measure if we're getting closer
        unsat_read = random.choice(list(self.unsat_reads))

        # find writes to unsat_read storage offset
        sstores = [s for s in self.project.statement_at.values() if s.__internal_name__ == 'SSTORE']
        interesting_sstores = list()
        for sstore in sstores:
            offset_term = sstore.arg1_val
            if offset_term == unsat_read:
                interesting_sstores.append(sstore)

        chosen_sstore = random.choice(interesting_sstores)

        xid = gen_exec_id()
        entry_state = self.project.factory.entry_state(xid=xid)
        simgr = self.project.factory.simgr(entry_state=entry_state)
        options.LAZY_SOLVES = True

        directed_search = DirectedSearch(chosen_sstore)
        simgr.use_technique(directed_search)

        dfs = DFS()
        simgr.use_technique(dfs)

        monitor_sload = MonitorSLOAD()
        simgr.use_technique(monitor_sload)

        simgr.run(find=lambda s: s.curr_stmt.id == chosen_sstore.id)

        if simgr.found and simgr.one_found.solver.is_sat():
            state = simgr.one_found
            calldata = Exploit._get_calldata(state)
            all_reads = Exploit._get_all_reads(state)

            self.transactions.insert(0, (calldata, state.trace, all_reads))

    @staticmethod
    def from_state(project, state):
        assert state.solver.is_sat()
        exploit = Exploit(project)

        calldata = exploit._get_calldata(state)
        all_reads = exploit._get_all_reads(state)

        exploit.transactions.insert(0, (calldata, state.trace, all_reads))

        return exploit

    def dump(self):
        for t in self.transactions:
            print(t[0])


def main(args):
    p = Project(target_dir=args.target)

    target_stmt = None
    target_stmt_id = None

    if args.addr in p.statement_at:
        target_stmt_id = args.addr
        target_stmt = p.factory.statement(target_stmt_id)
    elif args.addr in p.block_at:
        target_block_id = args.addr
        target_block = p.factory.block(target_block_id)
        target_stmt = target_block.first_ins
        target_stmt_id = target_stmt.id
    else:
        print('Please specify a target address.')
        exit(1)

    xid = gen_exec_id()
    entry_state = p.factory.entry_state(xid=xid)

    simgr = p.factory.simgr(entry_state=entry_state)

    options.LAZY_SOLVES = True

    directed_search = DirectedSearch(target_stmt)
    simgr.use_technique(directed_search)

    dfs = DFS()
    simgr.use_technique(dfs)

    heartbeat = HeartBeat()
    simgr.use_technique(heartbeat)

    monitor_sload = MonitorSLOAD()
    simgr.use_technique(monitor_sload)

    try:
        simgr.run(find=lambda s: s.curr_stmt.id == target_stmt_id)
    except KeyboardInterrupt:
        pass

    if not simgr.found:
        log.fatal('No paths found')
        exit()

    found = simgr.found.pop()
    exploit = Exploit.from_state(p, found)

    while not exploit.is_sat_remote():
        exploit.refine()

    log.info(f'Successfully generated exploit:')
    caller = exploit.final_state.solver.eval(exploit.final_state.ctx['CALLER']).to_bytes(20, 'big').hex()
    log.info(f'CALLER: 0x{caller}')
    exploit.dump()



if __name__ == "__main__":
    parser = argparse.ArgumentParser()

    parser.add_argument("target", type=str, action="store", help="Path to Gigahorse output folder")
    parser.add_argument("--addr", type=str, action="store", help="Target address", required=True)
    parser.add_argument("-d", "--debug", action="store_true", help="Enable debug output")

    args = parser.parse_args()

    # setup logging
    if args.debug:
        log.setLevel("DEBUG")
    else:
        log.setLevel("INFO")

    main(args)
